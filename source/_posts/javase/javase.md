---
layout: "post"
title: "Java基础知识"
date: "2019-05-12 14:22"
categories: javase
tags: [javase]
---

## if 语句
### 三元运算符与if语句
三元运算符能实现的都可采用if语句实现，反之不成立。因为三元运算符不能执行输出语句。
若只需赋值，可用三元运算符简化代码。

## switch语句
### switch表达式可接收类型
1. 基本数据类型可以接收byte,short,char,int
2. 引用数据类型可以接收枚举(JDK1.5) String类型(JDK1.7)

### swith语句注意事项
- case后面只能是常量，不能是变量。多个case的值不能相同
- 每个case后面都要加break，否则会出现case穿透
- default可以放在任何位置，但建议放最后

## if语句和switch语句的各自使用场景
switch在判断固定值时使用，if建议判断区间和范围时使用

## for语句、while语句和do while语句
### 三者区别
- do while 先执行循环体再判断，至少会执行一次循环体
- for语句执行后，变量会被释放，不能再使用；while执行后，初始化变量还能继续使用

如果想在循环结束后继续使用控制条件的变量，用while语句，否则尽量用for循环，以提高内存的使用效率

### 无限循环语句
while语句无限循环： 
```java 
while(true) {
  System.out.println("This is a loop");
}
```
for语句的无限循环:
```java
for(; ;) {
  System.out.println("This is a loop");
}
```
### 转义字符
`\x` x表示任意，\是转义符号，这种做法叫转义字符

- `\t` 表示tab键(制表符)
- `\r` 表示回车
- `\n` 表示换行
- `\"` 表示转义双引号
- `\'` 表示转义单引号

## 方法的概述和格式说明
```java 
/**
* 修饰符 返回值类型 方法名(参数类型 参数名1, 参数类型2 参数名2...) {
*    方法体语句
*    return 返回值;
* }
*/
```
### 方法的注意事项
- 方法不调用不执行
- 方法与方法是平级关系，不能嵌套定义
- 方法定义的时候参数之间用逗号隔开

### 方法的重载
重载： 方法名相同，参数列表不同，与返回值类型无关
重载的分类： 
- 参数的个数不同
- 参数的类型不同
- 参数的顺序不同

## 数组

同时存储同一种数据类型多个元素的集合，既可存储基本数据类型，也可存储引用数据类型。

格式： `数据类型[] 数组名 = new 数据类型[数组的长度]`

### 数组的初始化

#### 动态初始化

`数据类型[] 数组名 = new 数据类型[数组的长度]`

e.g: int[] arr = new int[5]

相当于在内存中开辟5个连续的储存空间

### java中的内存分配以及栈和堆的区别

栈： 存储局部变量(定义在方法声明上和方法中的变量)，每个方法是一个栈针形式
堆： 存储new出来的数组或对象
方法区：
本地方法区： 和系统相关
寄存器: 给CPU用

### 静态初始化

格式： `数据类型[] 数组名 = new 数据类型[]{元素1, 元素2, ...}`
简化格式： `数据类型[] 数组名 = {元素1, 元素2, ...}`

简化格式的声明和赋值只能在同一行，否则编译不通过。  

### 参数传递问题

基本数据类型的值传递，不改变原值，因为调用后会弹栈，局部变量随之消失
引用数据类型的值传递，改变原值，因为即使方法弹栈，但是堆内存数组对象还在，可以通过地址继续访问

java中只有传值，因为地址值也是值

## 构造方法、static关键字 (day 07)
### 构造方法特点
- 方法名和类名相同
- 没有返回值类型，连void也没有
- 没有具体的返回值，直接return
- 若无构造方法，系统会自动提供一个无参的构造方法
- 若有有参构造方法，则必须自己写一个无参的构造方法
 ### 创建对象的步骤
 1. Student.class加载进内存
 2. 声明一个Student类型引用s
 3. 在堆内存创建对象
 4. 给对象中属性默认初始化值
 5. 属性进行显示初始化
 6. 构造方法进栈，对对象中的属性赋值，构造方法弹栈
 7. 将对象的地址赋值给s

 ![创建对象步骤图解](/data/img/javase/创建对象的步骤.jpg)

 ### static关键字及内存图(day07 07.09)

 ![static内存图](/data/img/javase/static内存图.png)

 #### static关键字的特点
 - 随着类的加载而加载
 - 优先于对象存在
 - 被类的所有对象共享
    当某个成员变量是被所有对象所共享，那么它就应该送一位静态的
 - 可以通过类名调用，推荐使用类名调用；静态修饰的内容，一般我们称其为与类相关的，类成员

 #### static的注意事项
 a. 在静态方法中是没有this关键字的，因为静态是随着累的加载而加载，优先于对象的存在，而this是随着对象的创建而存在的
 b. 静态方法只能访问静态的成员变量和静态的成员方法

#### 静态变量和成员变量的区别
a. 所属不同
    * 静态变量属于类，所以也称为类变量
    * 成员变量属于对象，所以也称为实例变量(对象变量)
b. 内存中的位置不同
    * 静态变量存储于方法区的静态区
    * 成员变量存储于堆内存
c. 内存出现时间不同
    * 静态变量随着类的加载而加载，随着类的消失而消失
    * 成员变量随着对象的创建而存在，随着对象的消失而消失
d. 调用不同
    * 静态变量可以通过类名调用，也可以通过对象调用
    * 成员变量只能通过对象名调用

### main方法的格式和详细解释

public : 被jvm调用，所以需要权限足够大
static : 被jvm调用，不需要创建对象，直接类名.调用即可
void : 被jvm调用，不需要有任何的返回值
main : 只有这样写才能被jvm识别，main不是关键字
String[] args : 以前用来接收启动时的键盘录入，现在用System.Scanner(System.in)来接收键盘录入

 ![main方法String[]](/data/img/javase/main方法String[].jpg)

### 工具类中使用静态
工具类中使用静态方法，可不用创建对象直接调用；若一个类中所有的方法都为静态方法，则需要将构造方法私有化，目的是不让其他类创建本类，直接用类名.方法调用即可

### 说明书的制作过程
1. 使用多行注释在类和方法中进行注释，写明版本、作者、参数、返回值等信息
2. 对需要生成api的文件进行javadoc命令

![生成说明文档](/data/img/javase/generateApi.png)

`javadoc -d api -version -author ArrayTools.java`
 - `javadoc` 生成文档命令
 - `-d api` 文件生成保存路径
 - `-version` 版本
 - `-author` 作者
 - `ArrayTools.java` 源文件类的名字

 文件生成后，直接打开`index.html`既可

## 代码块、继承、方法重写、final关键字(day 08)
### 代码块
java中使用`{}`括起来的代码称为代码块，分为局部代码块、构造代码块、静态代码块、同步代码块

- 局部代码块： 在方法中出现，限定变量的生命周期，及早释放，提高内存效率
- 构造代码块(初始化代码块)：在类中方法外出现；多个构造方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行
- 静态代码块： 在类中方法外出现，加了static修饰；用于给类进行初始化，在加载时执行，并且只执行一次，一般用于加载驱动

### 继承
关键字： extends
让类与类之间产生关系，子父类关系
好处： 
   - 提高代码的复用性
   - 提高了代码的维护性
   - 让类与类之间产生了关系，是多态的前提
弊端：
  - 增强类的耦合性

开发的原则： 高内聚，低耦合
 - 耦合是指类与类的关系
 - 内聚是指自己完成某件事情的能力

 #### 继承的特点
 java只支持单继承不支持多继承，但支持多层继承(B extends A, C extends B)

 #### 继承的注意事项
 - 子类只能继承父类所有非私有成员(成员方法和成员变量)
 - 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法
 - 不要为了部分功能而去继承

 #### this和super的区别
 `this.成员变量` ：既可以调用本类的成员变量，也可调用父类成员变量(本类无成员变量) 
 `super.成员变量` : 调用父类成员变量

 #### 继承中构造方法的关系
 子类中所有的构造方法默认都会访问父类中空参数的构造方法。
 每一个构造方法的第一条语句默认都是 super() Object类最顶层的父类

 #### 继承中构造方法的注意事项
 父类没有无参构造方法，子类只能通过super或者this来访问父类的有参构造方式。super和this不能共用，因为两者都必须放在构造器中的第一个语句。

 ### 方法的重写
 子父类出现了一模一样的方法
 子类可以重写父类中的方法，这样既沿袭了父类的功能，又定义了自己特有的功能

 #### 方法重写的注意事项
 1. 父类的思想方法不能被重写
 2. 子类重写父类方法时，访问权限不能更低
 3. 父类静态方法，子类也必须通过静态方法重写(静态方法只能覆盖静态方法)

#### 方法的重载(overload)和重写(overload)
方法重写： 子父类出现一模一样的方法，与返回值类型有关，返回值是一致的
方法重载： 在本类中出现的方法名一样，参数列表不同，与返回值无关

### final关键字
#### 特点
- 修饰类，类不能被继承
- 修饰变量， 变量变为常量，只能被赋值一次
- 修饰方法， 方法不能被重写 

final修饰基本数据类型，值不能被改变；
final修饰引用数据类型，地址值不能被改变，但对象中的属性可以改变。

成员变量的从默认初始化值是无效值，因此final修饰的成员变量初始化时需要赋值或者利用构造方法初始化。

## 多态、抽象类
### 多态
#### 多态的前提
1. 要有继承关系
2. 要有方法重写
3. 要有父类引用指向子类方法

#### 多态中的成员访问特点
##### 成员变量
编译看左边(父类)，运行看左边(父类)

##### 成员方法
编译看左边(父类)，运行看右边(子类)  (动态绑定)

##### 静态方法
编译看左边(父类)，运行看左边(父类)

#### 向上转型和向下转型
引用数据类型会先向上转型，才能向下转型。

#### 好处和弊端
好处：
- 提高代码的可维护性
- 提高代码的扩展性

弊端：
- 不能使用子类的特有属性和行为
多态一般用于当做参数，因为其拓展性强

### 抽象类
#### 特点
关键字abstract修饰
- 抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或接口
- 抽象类不能实例化，只能通过子类实例化
- 抽象的子类只能是抽象类或重写抽象类的所有方法

#### 成员特点
- 成员变量既可以是变量也可以是常量。
- 有构造方法，便于子类访问父类数据的初始化
- 成员方法，既可以是抽象也可以是非抽象(非抽象需要重写父类所有方法)

#### 面试题
1. 一个抽象类如果没有抽象方法，可以定义为抽象类，这样做是为了不让其他类创建本类的对象，只能通过此抽象的子类实例化
2. abstract不能和那些关键字共存
    - `static `
    
      被`abstract`修饰的方法没有方法体，被`static`修饰的可以用类名.调用，调用抽象方法是没有意义的
    - `final`
    
      被`abstract`修饰的方法强制子类重写，被`final`修饰的不让子类重写
    - `private`
    
      被`abstract`修饰的是为了让子类看到并强制重写，被`private`修饰不让子类访问
  
### 接口(interface) 
1. 使用关键字`interface`表示，接口中的方法都是抽象的。
2. 类实现接口用`implement`表示： `class 类名 implement 接口名 {}`
3. 接口不能实例化
4. 接口的子类可以是抽象类，也可以是具体类，但是具体类需要重写接口中的所有抽象方法

#### 接口的成员特点
1. 成员变量: 只能是常量，并且是静态、公共的，默认修饰符: `public static final`,建议手动给出
2. 构造方法： 接口没有构造方法
3. 成员方法： 只能是抽象方法，默认修饰符： `public abstract`，建议手动给出

### 类与类、类与接口、接口与接口的关系
类与类： 继承关系，只能是单继承，可以多层继承
类与接口： 实现关系，可以单实现，也可以多实现并且能在继承一个类的同时实现多个接口
接口与接口： 继承关系，可以是单继承，也可以是多继承

### 抽象类和接口的区别
成员区别： 
- 成员变量： 抽象类的可以是变量，也可以是常量；接口的只能是常量
- 构造方法： 抽象类有构造方法，接口无
- 成员方法： 抽象类的可以是抽象方法，也可以是非抽象；接口的只可以是抽象

设计理念区别：
- 抽象类被继承，体现的是`is a`的关系，抽象类定义的是该继承体系的共性功能
- 接口，被实现的是`like a`的关系，接口中定义的是该继承体系的扩展功能

## day10
### 四种权限修饰符
`public`、`defalut`、 `protected`、 `private`

- `private` 只能在本类中访问
- `default` 默认不写，能在本类和同包下访问
- `protected`在不同包下的无关类无法访问
- `public` 均能访问

状态修饰符： `static`、 `final`

### 局部内部类
方法中的内部类；
局部内部类访问局部变量，局部变量需要用final修饰。(JDK 1.8中取消了此事)

### 匿名内部类
匿名内部类只针对重写一个方法的时候使用。匿名内部类当做参数传递，本职是把匿名内部类看做一个对象。
链式编程，调用方法后还能继续调用方法，证明调用方法后返回的是一个对象

## eclipse、Object类
### eclipse快捷键
`alt + /` 提示代码
`ctrl + n` 新建
`ctrl + shift +f` 格式化
`ctrl + shif +o` 整理包
`ctrl + /`单行注释
`ctrl+shift+/` 多行注释
`ctrl + shift +\`
`alt + 上下箭头` 上下移动代码
`F3`或按住`ctrl`点击类名可以查看源码
`ctrl + shift + t` 查找具体的类
`ctrl + o`查找具体类的具体方法
`ctrl + d` 删除代码
`ctrl + shift + m` 抽取方法
`alt + shift + r` 改名
`alt + shift + s` 快速生成getter、setter等方法
`ctrl + alt + 上下键` 向上/下复制一行代码

### 打jar包
选中项目-->右键-->Export-->java-->Jar-->指定路径和名称-->finish

### 导入jar包
选中jar包-->右键-->build path

### Object类
1. hashcode()方法： 返回对象的地址值。

2. getClass()方法： 返回对象的class文件。

3. toString()方法： 更方便的显示属性值。如果直接打印对象的引用，会默认调用toString方法。

4. equals方法： 判断两个对象是否相等(比较的是地址值)，返回布尔值。Object的equals方法比较的是地址值，因此开发中没什么意义，一般都要重写此方法，重写后一般比较的是对象中的属性值。

### == 和equals的区别
共同点： 都可以做比较，返回值都是布尔值
区别：
1. `==`是比较运算符，即可以比较基本数据类型，也可以比较引用数据类型。基本数据类型比较的是值，引用数据类型比较的是地址值

2. equals方法只能比较引用数据类型，equals方法在没重写之前比较的是地址值，底层依赖的是==号，但是比较地址值是没有意义的，需要重写equals方法比较对象中的属性值

